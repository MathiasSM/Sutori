-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Sutori language compiler
--   
--   Please see the README on GitHub at
--   <a>https://github.com/MathiasSM/Sutori#readme</a>
@package sutori
@version 0.2.0


module Sutori.Error.Error

-- | Different possible Sutori Errors
data SutError

-- | An unknown or malformed token was read
LexicalError :: SutError

-- | The source code does not follow Sutori grammar
GrammaticalError :: SutError

-- | A Type error occurred
TypeError :: SutError

-- | A symbol was used before it was defined
UndefinedSymbolError :: SutError

-- | A function was called with the wrong number of arguments
ArgumentsNumberError :: SutError

-- | A symbol was defined twice in the same scope
DuplicateSymbolError :: SutError

-- | The compiler failed for a known reason (not the user's fault)
InternalError :: SutError

-- | The lack of error
NoError :: SutError
instance GHC.Show.Show Sutori.Error.Error.SutError


module Sutori.Lexer.Posn

-- | Source position (Characters before, Row number, Column number)
data SutPosn
SutPosn :: !Int -> !Int -> !Int -> SutPosn

-- | Initial position of the scanner
initialPosn :: SutPosn
instance GHC.Show.Show Sutori.Lexer.Posn.SutPosn
instance GHC.Classes.Eq Sutori.Lexer.Posn.SutPosn


module Sutori.Lexer.Tokens

-- | Sutori token classes. Their RegEx' are defined in Alex file
data SutToken
SutTkEOF :: SutToken
BLOCK_OPEN :: SutToken
BLOCK_CLOSE :: SutToken
PROGRAM_INI :: SutToken
PROGRAM_FIN :: SutToken
FUNCTION_INI :: SutToken
FUNCTION_DECLARE :: SutToken
FUNCTION_DEFINE :: SutToken
S_andthatswhere :: SutToken
S_therewas :: SutToken
S_brokea :: SutToken
S_broughta :: SutToken
S_comesfrom :: SutToken
S_dreamsof :: SutToken
S_keepsdreamingof :: SutToken
S_madea :: SutToken
S_madeof :: SutToken
S_therewasa :: SutToken
S_toldthatstory :: SutToken
S_invented :: SutToken
S_itsa :: SutToken
S_andnothingelse :: SutToken
S_wewillskipthis :: SutToken
TYPE_INT :: SutToken
TYPE_FLOAT :: SutToken
TYPE_CHAR :: SutToken
TYPE_VOID :: SutToken
TYPE_BOOL :: SutToken
TYPE_ARRAY :: SutToken
TYPE_STRUCT :: SutToken
TYPE_UNION :: SutToken
TYPE_STRING :: SutToken
TYPE_POINTER :: SutToken
OPEN_PAREN :: SutToken
OPEN_BRACKETS :: SutToken
OPEN_BRACES :: SutToken
CLOSE_PAREN :: SutToken
CLOSE_BRACKETS :: SutToken
CLOSE_BRACES :: SutToken
ELLIPSIS :: SutToken
PERIOD :: SutToken
COMMA :: SutToken
COLON :: SutToken
SEMICOLON :: SutToken
QUESTIONMARK :: SutToken
EXCLAMATION :: SutToken
ARROW_RIGHT :: SutToken
PLUS :: SutToken
MINUS :: SutToken
EQUAL :: SutToken
ASSIGNMENT :: SutToken
ASTERISK :: SutToken
PERCENT :: SutToken
SLASH :: SutToken
DIV :: SutToken
NOT_EQUAL :: SutToken
GREATER_EQUAL :: SutToken
LESS_EQUAL :: SutToken
GREATER :: SutToken
LESS :: SutToken
POWER :: SutToken
AND :: SutToken
OR :: SutToken
WITH :: SutToken
YOUR :: SutToken
OF :: SutToken
EITHER :: SutToken
TO :: SutToken
WHEN :: SutToken
OTHERWISE :: SutToken
TIMES :: SutToken
SutTkBool :: Bool -> SutToken
[tokenBool] :: SutToken -> Bool
SutTkChar :: String -> SutToken
[tokenChar] :: SutToken -> String
SutTkFloat :: Float -> SutToken
[tokenFloat] :: SutToken -> Float
SutTkInt :: Int -> SutToken
[tokenInt] :: SutToken -> Int
SutTkString :: String -> SutToken
[tokenString] :: SutToken -> String
SutTkError :: String -> SutToken
[tokenError] :: SutToken -> String
SutTkID :: String -> SutToken
[tokenID] :: SutToken -> String

-- | Says if the given token is valid (not an error) or not
isValid :: SutToken -> Bool
instance GHC.Show.Show Sutori.Lexer.Tokens.SutToken
instance GHC.Classes.Eq Sutori.Lexer.Tokens.SutToken


-- | Provides a common framework (class) to <a>showSut</a> sutori
--   components<i>elements</i>constructs.
module Sutori.Logger.Log

-- | Interface for pretty-printing Sutori constructs (token, actions,
--   tables, ...)
class SutShow a

-- | Allows to pretty-print a Sutori (internal or external) element
showSut :: SutShow a => a -> SutLog

-- | Simple tree data structure to allow pretty printing of sutori logs
data SutLog

-- | A final message
SutLogLeave :: String -> SutLog

-- | A message with children messages
SutLogNode :: String -> [SutLog] -> SutLog

-- | Extract log strings
fromLeave :: SutLog -> String
instance GHC.Show.Show Sutori.Logger.Log.SutLog


-- | Provides a common framework (class) to <a>showSut</a> sutori
--   components<i>elements</i>constructs. Right now, error codes are
--   defined here.
module Sutori.Logger.Writer

-- | Sutori logger, where we register logs for <tt>reasons</tt>, via a
--   WriterT
data SutLogger
SutLogger :: [SutLog] -> [SutLog] -> [(SutError, SutLog)] -> SutLogger
instance GHC.Base.Monoid Sutori.Logger.Writer.SutLogger
instance GHC.Show.Show Sutori.Logger.Writer.SutLogger


-- | Provides a common framework (class) to <a>showSut</a> sutori
--   components<i>elements</i>constructs.
module Sutori.Logger

-- | Simple tree data structure to allow pretty printing of sutori logs
data SutLog

-- | A final message
SutLogLeave :: String -> SutLog

-- | A message with children messages
SutLogNode :: String -> [SutLog] -> SutLog

-- | Interface for pretty-printing Sutori constructs (token, actions,
--   tables, ...)
class SutShow a

-- | Allows to pretty-print a Sutori (internal or external) element
showSut :: SutShow a => a -> SutLog

-- | Sutori logger, where we register logs for <tt>reasons</tt>, via a
--   WriterT
data SutLogger
SutLogger :: [SutLog] -> [SutLog] -> [(SutError, SutLog)] -> SutLogger

-- | Extract log strings
fromLeave :: SutLog -> String


module Sutori.Lexer.Logger
instance Sutori.Logger.Log.SutShow Sutori.Lexer.Tokens.SutToken
instance Sutori.Logger.Log.SutShow Sutori.Lexer.Posn.SutPosn


module Sutori.Error.Logger
instance Sutori.Logger.Log.SutShow Sutori.Error.Error.SutError


module Sutori.Monad.Logger


module Sutori.Options.Options

-- | Options for command-line parsing
data Options
Options :: Bool -> Bool -> Maybe FilePath -> Bool -> Bool -> Bool -> Bool -> Bool -> Options

-- | Verbose switch
[optVerbose] :: Options -> Bool

-- | Debugging switch
[optDebug] :: Options -> Bool

-- | Output file
[optOutput] :: Options -> Maybe FilePath

-- | Mode: Show version
[optShowVersion] :: Options -> Bool

-- | Mode: Show help
[optShowHelp] :: Options -> Bool

-- | Mode: Run only lexer
[optStopOnLexer] :: Options -> Bool

-- | Mode: Run only frontend
[optStopOnAST] :: Options -> Bool

-- | Mode: Run only until intermediate code generation
[optStopOnTAC] :: Options -> Bool

-- | The default options for a Sutori run
defaultOptions :: Options

-- | Parse command-line flags
handleFlags :: [String] -> IO (Options, [String])

-- | Complete usage information
usage :: String


module Sutori.Options.Logger
instance Sutori.Logger.Log.SutShow Sutori.Options.Options.Options


module Sutori.Options

-- | Options for command-line parsing
data Options
Options :: Bool -> Bool -> Maybe FilePath -> Bool -> Bool -> Bool -> Bool -> Bool -> Options

-- | Verbose switch
[optVerbose] :: Options -> Bool

-- | Debugging switch
[optDebug] :: Options -> Bool

-- | Output file
[optOutput] :: Options -> Maybe FilePath

-- | Mode: Show version
[optShowVersion] :: Options -> Bool

-- | Mode: Show help
[optShowHelp] :: Options -> Bool

-- | Mode: Run only lexer
[optStopOnLexer] :: Options -> Bool

-- | Mode: Run only frontend
[optStopOnAST] :: Options -> Bool

-- | Mode: Run only until intermediate code generation
[optStopOnTAC] :: Options -> Bool

-- | Complete usage information
usage :: String

-- | Parse command-line flags
handleFlags :: [String] -> IO (Options, [String])

-- | The default options for a Sutori run
defaultOptions :: Options


module Sutori.Types.Primitives

-- | Sutori primitives
data SutPrimitive

-- | A bag (Int)
SutBag :: SutPrimitive

-- | A wallet (Float)
SutWallet :: SutPrimitive

-- | A phrase (String)
SutPhrase :: SutPrimitive

-- | A light (Bool)
SutLight :: SutPrimitive

-- | A letter (Char)
SutLetter :: SutPrimitive

-- | A void element (Void)
SutTypeVoid :: SutPrimitive

-- | A Type Error (&amp;^%$#)
SutTypeError :: SutPrimitive

-- | A type will be represented by an ID
type SutTypeID = Int

-- | Predefined Sutori types to initialize symtable
primitives :: [SutPrimitive]

-- | Defines sizes for each primitive ("in bytes"-ish)
primitiveSize :: SutPrimitive -> Int

-- | Eventual TypeIDs for the type graph
primitiveID :: SutPrimitive -> SutTypeID

-- | Zipped primitives with their IDs
primitiveIDs :: [(SutPrimitive, SutTypeID)]

-- | Given two types, this is the most general one (LCA) Right now LCA is
--   just always one of them
generalizePrimitives :: SutPrimitive -> SutPrimitive -> SutPrimitive

-- | Convert primitive to boolean type
toTypeLight :: SutPrimitive -> SutPrimitive

-- | Convert primitive to the most specific numerical type available
toTypeNum :: SutPrimitive -> SutPrimitive

-- | Convert primitive to the most specific numerical type available
toTypeBag :: SutPrimitive -> SutPrimitive

-- | Convert primitive to the general float type
toTypeWallet :: SutPrimitive -> SutPrimitive

-- | Convert primitive to the most general string (printable) type
toTypePhrase :: SutPrimitive -> SutPrimitive

-- | Convert primitive to a sortable type or error
toTypeSortable :: SutPrimitive -> SutPrimitive

-- | Convert primitive to a equalable type or error
toTypeEq :: SutPrimitive -> SutPrimitive
instance GHC.Show.Show Sutori.Types.Primitives.SutPrimitive
instance GHC.Classes.Ord Sutori.Types.Primitives.SutPrimitive
instance GHC.Classes.Eq Sutori.Types.Primitives.SutPrimitive


module Sutori.Utils.List

-- | Conjunction of a the results of a list of functions applied to a
--   single value
anyf :: [a -> Bool] -> a -> Bool

-- | Conjunction of a the results of a list of functions applied to a
--   single value
allf :: [a -> Bool] -> a -> Bool

-- | Filters out unique elements in a list
repeated :: Ord a => [a] -> [a]

-- | Filters consecutive uniques, given a grouping and a sorting function
repeatedBy :: (Eq c, Ord b) => (a -> c) -> (a -> b) -> [a] -> [a]

-- | Filters a list with a given filter function
filterBy :: Ord a => ([a] -> Bool) -> [a] -> [[a]]


module Sutori.Utils

-- | Conjunction of a the results of a list of functions applied to a
--   single value
anyf :: [a -> Bool] -> a -> Bool

-- | Conjunction of a the results of a list of functions applied to a
--   single value
allf :: [a -> Bool] -> a -> Bool

-- | Filters a list with a given filter function
filterBy :: Ord a => ([a] -> Bool) -> [a] -> [[a]]

-- | Filters out unique elements in a list
repeated :: Ord a => [a] -> [a]

-- | Filters consecutive uniques, given a grouping and a sorting function
repeatedBy :: (Eq c, Ord b) => (a -> c) -> (a -> b) -> [a] -> [a]

-- | Global type for Sutori IDs
type SutID = String


module Sutori.Types.Constructors

-- | A type will be represented by an ID
type SutTypeID = Int

-- | Sutori type constructors
data SutType

-- | A Primitive Type
SutPrimitiveType :: SutPrimitive -> SutType

-- | A Direction (Pointer) to a value of some type
SutDirection :: SutTypeID -> SutType

-- | A Chain (Array) of fixed size of element type
SutChain :: Int -> SutTypeID -> SutType

-- | A Machine (Struct) of different components
SutMachine :: [(SutID, SutTypeID)] -> SutType

-- | A Thing (Union) that might have different names
SutThing :: [(SutID, SutTypeID)] -> SutType

-- | Extract the primitive from the type definition
primitiveType :: SutType -> SutPrimitive

-- | Generalize two types to their LCA, if any
generalizeTypes :: SutType -> SutType -> SutType

-- | Constant primitive error type
primitiveError :: SutType
instance GHC.Show.Show Sutori.Types.Constructors.SutType
instance GHC.Classes.Ord Sutori.Types.Constructors.SutType
instance GHC.Classes.Eq Sutori.Types.Constructors.SutType


module Sutori.Types.Graph

-- | The type graph must be a biderectional map (as there's a bijection
--   between type and its ID)
data TypeGraph
TypeGraph :: Map SutType (SutTypeID, Int) -> Map SutTypeID (SutType, Int) -> TypeGraph

-- | The initial value for the graph. That is, the primitives added
initialTypeGraph :: TypeGraph

-- | The initial value for the "next type ID"
initialNextTypeID :: Int

-- | Inserts a type mapping into the map
insertType :: (SutType, SutTypeID) -> TypeGraph -> TypeGraph

-- | Maybe the <a>SutTypeID</a> of the given type
lookupTypeID :: SutType -> TypeGraph -> Maybe (SutTypeID, Int)

-- | Maybe the type of the given <a>SutTypeID</a>
lookupType :: SutTypeID -> TypeGraph -> Maybe (SutType, Int)

-- | The graph as a list sorted by ID (first appearance?)
orderedGraph :: TypeGraph -> [(SutTypeID, (SutType, Int))]

-- | Lookup and check a member's offset
memberOffset :: SutType -> String -> Int


module Sutori.Types.Logger
instance Sutori.Logger.Log.SutShow Sutori.Types.Graph.TypeGraph
instance Sutori.Logger.Log.SutShow Sutori.Types.Primitives.SutPrimitive
instance Sutori.Logger.Log.SutShow Sutori.Types.Constructors.SutType


-- | TODO: Sort and document API
module Sutori.Types

-- | A type will be represented by an ID
type SutTypeID = Int

-- | Sutori type constructors
data SutType

-- | A Primitive Type
SutPrimitiveType :: SutPrimitive -> SutType

-- | A Direction (Pointer) to a value of some type
SutDirection :: SutTypeID -> SutType

-- | A Chain (Array) of fixed size of element type
SutChain :: Int -> SutTypeID -> SutType

-- | A Machine (Struct) of different components
SutMachine :: [(SutID, SutTypeID)] -> SutType

-- | A Thing (Union) that might have different names
SutThing :: [(SutID, SutTypeID)] -> SutType

-- | Extract the primitive from the type definition
primitiveType :: SutType -> SutPrimitive

-- | Generalize two types to their LCA, if any
generalizeTypes :: SutType -> SutType -> SutType

-- | Constant primitive error type
primitiveError :: SutType

-- | The type graph must be a biderectional map (as there's a bijection
--   between type and its ID)
data TypeGraph
TypeGraph :: Map SutType (SutTypeID, Int) -> Map SutTypeID (SutType, Int) -> TypeGraph

-- | The initial value for the graph. That is, the primitives added
initialTypeGraph :: TypeGraph

-- | The initial value for the "next type ID"
initialNextTypeID :: Int

-- | Inserts a type mapping into the map
insertType :: (SutType, SutTypeID) -> TypeGraph -> TypeGraph

-- | Maybe the <a>SutTypeID</a> of the given type
lookupTypeID :: SutType -> TypeGraph -> Maybe (SutTypeID, Int)

-- | Maybe the type of the given <a>SutTypeID</a>
lookupType :: SutTypeID -> TypeGraph -> Maybe (SutType, Int)

-- | The graph as a list sorted by ID (first appearance?)
orderedGraph :: TypeGraph -> [(SutTypeID, (SutType, Int))]

-- | Sutori primitives
data SutPrimitive

-- | A bag (Int)
SutBag :: SutPrimitive

-- | A wallet (Float)
SutWallet :: SutPrimitive

-- | A phrase (String)
SutPhrase :: SutPrimitive

-- | A light (Bool)
SutLight :: SutPrimitive

-- | A letter (Char)
SutLetter :: SutPrimitive

-- | A void element (Void)
SutTypeVoid :: SutPrimitive

-- | A Type Error (&amp;^%$#)
SutTypeError :: SutPrimitive

-- | Predefined Sutori types to initialize symtable
primitives :: [SutPrimitive]

-- | Eventual TypeIDs for the type graph
primitiveID :: SutPrimitive -> SutTypeID

-- | Zipped primitives with their IDs
primitiveIDs :: [(SutPrimitive, SutTypeID)]

-- | Given two types, this is the most general one (LCA) Right now LCA is
--   just always one of them
generalizePrimitives :: SutPrimitive -> SutPrimitive -> SutPrimitive

-- | Convert primitive to boolean type
toTypeLight :: SutPrimitive -> SutPrimitive

-- | Convert primitive to the most specific numerical type available
toTypeNum :: SutPrimitive -> SutPrimitive

-- | Convert primitive to the most specific numerical type available
toTypeBag :: SutPrimitive -> SutPrimitive

-- | Convert primitive to the general float type
toTypeWallet :: SutPrimitive -> SutPrimitive

-- | Convert primitive to the most general string (printable) type
toTypePhrase :: SutPrimitive -> SutPrimitive

-- | Convert primitive to a sortable type or error
toTypeSortable :: SutPrimitive -> SutPrimitive

-- | Convert primitive to a equalable type or error
toTypeEq :: SutPrimitive -> SutPrimitive

-- | Lookup and check a member's offset
memberOffset :: SutType -> String -> Int


module Sutori.AST.Nodes

-- | Global type for Sutori IDs
type SutID = String

-- | A <a>SutAST</a> is a list of instructions
type SutAST = [SutInstruction]

-- | A Sutori Module has a name and a SutAST
data SutModule
SutModule :: SutID -> SutAST -> SutModule

-- | A <tt>SutIntruction</tt> represents an instruction/action in the
--   (imperative) story
data SutInstruction

-- | Some expressions can be understood an an instruction on its own
InstExpression :: SutExpression -> SutInstruction

-- | The action of someone asking for the value of an expression
ReadVal :: SutID -> SutExpression -> SutInstruction

-- | The action of finishing a story with an expression
ReturnVal :: SutExpression -> SutInstruction

-- | A selection between two blocks of code given a true/false condition
Selection :: SutID -> SutExpression -> SutAST -> SutAST -> SutInstruction

-- | An unbounded iteration while a condition persists
IterationU :: SutID -> SutExpression -> SutAST -> SutInstruction

-- | A bounded iteration of a story to be repeated a number of times
IterationB :: SutID -> SutExpression -> SutAST -> SutInstruction

-- | The action of freeing a direction (so it points nowhere)
FreePointer :: SutID -> SutExpression -> SutInstruction

-- | The action of a person saying the value of an expression (into the
--   console)
PrintVal :: SutID -> SutExpression -> SutInstruction

-- | Stops the innermost iteration loop (skips the rest of the iteratons)
Break :: SutInstruction

-- | Skips the current iteration (stays in the loop, skips to next
--   iteration)
Continue :: SutInstruction

-- | A SutExpression
data SutExpression

-- | Indexing of an array to get an element
ArrayGet :: SutType -> SutExpression -> SutExpression -> SutExpression

-- | A binary operation
BinaryOp :: SutType -> SutOperator -> SutExpression -> SutExpression -> SutExpression

-- | An unary operation
UnaryOp :: SutType -> SutOperator -> SutExpression -> SutExpression

-- | A function call
SutCall :: SutType -> SutID -> [SutExpression] -> SutExpression

-- | A direction (pointer) creation
CreatePointer :: SutType -> SutID -> SutExpression

-- | A construct (machines, chains, etc...)
ExprConstructor :: SutType -> SutConstructor -> SutExpression

-- | An ID as an expression
ExprID :: SutType -> SutID -> Scope -> SutExpression

-- | A literal
ExprLiteral :: SutType -> SutLiteral -> SutExpression

-- | Dereference of a direction (pointer)
Dereference :: SutType -> SutExpression -> SutExpression

-- | Access to a member of a structured value
MemberGet :: SutType -> SutExpression -> SutID -> SutExpression

-- | A <a>SutLiteral</a> represents a literal expression
data SutLiteral

-- | Phrase (String)
SutString :: String -> SutLiteral

-- | Bag (Int)
SutInt :: Int -> SutLiteral

-- | Wallet (Float)
SutFloat :: Float -> SutLiteral

-- | Letter (Char)
SutChar :: String -> SutLiteral

-- | Light (Bool)
SutBool :: Bool -> SutLiteral

-- | Complex data structure constructors
data SutConstructor

-- | <a>Literal</a> Chains (Srrays)
SutArray :: [SutExpression] -> SutConstructor

-- | <a>Literal</a> Machines (Structs)
SutStruct :: [(SutID, SutExpression)] -> SutConstructor

-- | Sutori operators
data SutOperator

-- | Unary plus/make positive
SutOpPos :: SutOperator

-- | Unary minus/negate
SutOpNeg :: SutOperator

-- | Unary not
SutOpNot :: SutOperator

-- | Unary dereference
SutOpDer :: SutOperator

-- | Binary addition
SutOpAdd :: SutOperator

-- | Binary substraction
SutOpSub :: SutOperator

-- | Binary multiplication
SutOpMul :: SutOperator

-- | Binary division
SutOpDiv :: SutOperator

-- | Binary integer division
SutOpIntDiv :: SutOperator

-- | Binary modulo
SutOpMod :: SutOperator

-- | Binary power
SutOpPow :: SutOperator

-- | Binary and
SutOpAnd :: SutOperator

-- | Binary or
SutOpOr :: SutOperator

-- | Binary equal
SutOpEqual :: SutOperator

-- | Binary not equal
SutOpNotEq :: SutOperator

-- | Binary greater or equal than
SutOpGEq :: SutOperator

-- | Binary less or equal than
SutOpLEq :: SutOperator

-- | Binary greater than
SutOpGreater :: SutOperator

-- | Binary less than
SutOpLess :: SutOperator

-- | Binary assignment
SutOpAssign :: SutOperator

-- | Binary indexation
SutOpIndex :: SutOperator

-- | Binary member get
SutOpMember :: SutOperator
instance GHC.Classes.Eq Sutori.AST.Nodes.SutModule
instance GHC.Show.Show Sutori.AST.Nodes.SutModule
instance GHC.Classes.Eq Sutori.AST.Nodes.SutInstruction
instance GHC.Show.Show Sutori.AST.Nodes.SutInstruction
instance GHC.Classes.Eq Sutori.AST.Nodes.SutConstructor
instance GHC.Show.Show Sutori.AST.Nodes.SutConstructor
instance GHC.Classes.Eq Sutori.AST.Nodes.SutExpression
instance GHC.Show.Show Sutori.AST.Nodes.SutExpression
instance GHC.Classes.Eq Sutori.AST.Nodes.SutOperator
instance GHC.Show.Show Sutori.AST.Nodes.SutOperator
instance GHC.Classes.Eq Sutori.AST.Nodes.SutLiteral
instance GHC.Show.Show Sutori.AST.Nodes.SutLiteral


module Sutori.AST.Utils

-- | Extracts the type from any expression
expressionType :: SutExpression -> SutType

-- | Clones the expression overriding the type for the given primitive type
--   This is used for type coersion, mostly
withPrimitiveType :: SutPrimitive -> SutExpression -> SutExpression

-- | Clones the expression but sets the type as a TypeError
asTypeError :: SutExpression -> SutExpression


module Sutori.AST.Logger
instance Sutori.Logger.Log.SutShow Sutori.AST.Nodes.SutModule
instance Sutori.Logger.Log.SutShow Sutori.AST.Nodes.SutInstruction
instance Sutori.Logger.Log.SutShow Sutori.AST.Nodes.SutExpression
instance Sutori.Logger.Log.SutShow Sutori.AST.Nodes.SutLiteral
instance Sutori.Logger.Log.SutShow Sutori.AST.Nodes.SutConstructor
instance Sutori.Logger.Log.SutShow Sutori.AST.Nodes.SutOperator


module Sutori.AST

-- | Global type for Sutori IDs
type SutID = String

-- | A <a>SutAST</a> is a list of instructions
type SutAST = [SutInstruction]

-- | A Sutori Module has a name and a SutAST
data SutModule
SutModule :: SutID -> SutAST -> SutModule

-- | A <tt>SutIntruction</tt> represents an instruction/action in the
--   (imperative) story
data SutInstruction

-- | Some expressions can be understood an an instruction on its own
InstExpression :: SutExpression -> SutInstruction

-- | The action of someone asking for the value of an expression
ReadVal :: SutID -> SutExpression -> SutInstruction

-- | The action of finishing a story with an expression
ReturnVal :: SutExpression -> SutInstruction

-- | A selection between two blocks of code given a true/false condition
Selection :: SutID -> SutExpression -> SutAST -> SutAST -> SutInstruction

-- | An unbounded iteration while a condition persists
IterationU :: SutID -> SutExpression -> SutAST -> SutInstruction

-- | A bounded iteration of a story to be repeated a number of times
IterationB :: SutID -> SutExpression -> SutAST -> SutInstruction

-- | The action of freeing a direction (so it points nowhere)
FreePointer :: SutID -> SutExpression -> SutInstruction

-- | The action of a person saying the value of an expression (into the
--   console)
PrintVal :: SutID -> SutExpression -> SutInstruction

-- | Stops the innermost iteration loop (skips the rest of the iteratons)
Break :: SutInstruction

-- | Skips the current iteration (stays in the loop, skips to next
--   iteration)
Continue :: SutInstruction

-- | A SutExpression
data SutExpression

-- | Indexing of an array to get an element
ArrayGet :: SutType -> SutExpression -> SutExpression -> SutExpression

-- | A binary operation
BinaryOp :: SutType -> SutOperator -> SutExpression -> SutExpression -> SutExpression

-- | An unary operation
UnaryOp :: SutType -> SutOperator -> SutExpression -> SutExpression

-- | A function call
SutCall :: SutType -> SutID -> [SutExpression] -> SutExpression

-- | A direction (pointer) creation
CreatePointer :: SutType -> SutID -> SutExpression

-- | A construct (machines, chains, etc...)
ExprConstructor :: SutType -> SutConstructor -> SutExpression

-- | An ID as an expression
ExprID :: SutType -> SutID -> Scope -> SutExpression

-- | A literal
ExprLiteral :: SutType -> SutLiteral -> SutExpression

-- | Dereference of a direction (pointer)
Dereference :: SutType -> SutExpression -> SutExpression

-- | Access to a member of a structured value
MemberGet :: SutType -> SutExpression -> SutID -> SutExpression

-- | A <a>SutLiteral</a> represents a literal expression
data SutLiteral

-- | Phrase (String)
SutString :: String -> SutLiteral

-- | Bag (Int)
SutInt :: Int -> SutLiteral

-- | Wallet (Float)
SutFloat :: Float -> SutLiteral

-- | Letter (Char)
SutChar :: String -> SutLiteral

-- | Light (Bool)
SutBool :: Bool -> SutLiteral

-- | Complex data structure constructors
data SutConstructor

-- | <a>Literal</a> Chains (Srrays)
SutArray :: [SutExpression] -> SutConstructor

-- | <a>Literal</a> Machines (Structs)
SutStruct :: [(SutID, SutExpression)] -> SutConstructor

-- | Sutori operators
data SutOperator

-- | Unary plus/make positive
SutOpPos :: SutOperator

-- | Unary minus/negate
SutOpNeg :: SutOperator

-- | Unary not
SutOpNot :: SutOperator

-- | Unary dereference
SutOpDer :: SutOperator

-- | Binary addition
SutOpAdd :: SutOperator

-- | Binary substraction
SutOpSub :: SutOperator

-- | Binary multiplication
SutOpMul :: SutOperator

-- | Binary division
SutOpDiv :: SutOperator

-- | Binary integer division
SutOpIntDiv :: SutOperator

-- | Binary modulo
SutOpMod :: SutOperator

-- | Binary power
SutOpPow :: SutOperator

-- | Binary and
SutOpAnd :: SutOperator

-- | Binary or
SutOpOr :: SutOperator

-- | Binary equal
SutOpEqual :: SutOperator

-- | Binary not equal
SutOpNotEq :: SutOperator

-- | Binary greater or equal than
SutOpGEq :: SutOperator

-- | Binary less or equal than
SutOpLEq :: SutOperator

-- | Binary greater than
SutOpGreater :: SutOperator

-- | Binary less than
SutOpLess :: SutOperator

-- | Binary assignment
SutOpAssign :: SutOperator

-- | Binary indexation
SutOpIndex :: SutOperator

-- | Binary member get
SutOpMember :: SutOperator

-- | Extracts the type from any expression
expressionType :: SutExpression -> SutType

-- | Clones the expression overriding the type for the given primitive type
--   This is used for type coersion, mostly
withPrimitiveType :: SutPrimitive -> SutExpression -> SutExpression

-- | Clones the expression but sets the type as a TypeError
asTypeError :: SutExpression -> SutExpression


module Sutori.TAC.TAC
data TACTable

-- | Table of triplets
TACTable :: [Int] -> [TAC] -> TACTable

-- | Table of pointers to triplets
[tacInstructions] :: TACTable -> [Int]
[tacTriplets] :: TACTable -> [TAC]

-- | TACAddress for TAC Instructions
data TACAddress

-- | An actual ID from the source code. Identified using <a>SutID</a> and
--   <tt>Scope</tt>. Used for variables
TACName :: (SutID, Int) -> TACAddress

-- | A literal either explicit in the source code or calculated on the run.
TACLit :: SutLiteral -> TACAddress

-- | The TAC number that calculated the relevant expression.
TACID :: Int -> TACAddress

-- | An inc label to some code.
TACLabel :: Int -> TACAddress

-- | A TAC Instruction to be appended to the generated intermediate code
data TACType

-- | For simple expressions.
Basic :: SutOperator -> TACType
[tacOp] :: TACType -> SutOperator

-- | Copy operation, from a address to another
Copy :: TACType

-- | Address for an indirection
Addr :: TACType

-- | Unconditional jump, just where to.
Jump :: TACType

-- | Condition jump
JumpUnless :: TACType

-- | Assign a address from a indirect pointer.
Pointed :: TACType

-- | Stack a function parameter
Param :: TACType

-- | Call a function of so many (already stacked) parameters
Call :: TACType

-- | Return from a function (possibly a value).
Return :: TACType

-- | Perform a syscall (IO, Mem, else)
SysCall :: SutSys -> TACType
[tacSys] :: TACType -> SutSys

-- | TAC Instruction
data TAC

-- | Second address. Usually second operand. |A numbered label to output
--   literally
TAC :: TACType -> Maybe TACAddress -> Maybe TACAddress -> TAC

-- | Operation to perform
[tacType] :: TAC -> TACType

-- | First address. Usually first operand.
[tac1] :: TAC -> Maybe TACAddress
[tac2] :: TAC -> Maybe TACAddress
Label :: Int -> TAC

-- | A string label to output literally
FunLabel :: SutID -> TAC

-- | Represents a kind of possible system call
data SutSys

-- | IO Read operation
SysRead :: SutSys

-- | IO Print operation
SysPrint :: SutSys

-- | Memory allocation operation
SysAlloc :: SutSys

-- | Memory freeing operation
SysFree :: SutSys


module Sutori.TAC.Logger
instance Sutori.Logger.Log.SutShow Sutori.TAC.TAC.TACTable
instance Sutori.Logger.Log.SutShow Sutori.TAC.TAC.TACAddress
instance Sutori.Logger.Log.SutShow Sutori.TAC.TAC.TAC
instance Sutori.Logger.Log.SutShow Sutori.TAC.TAC.TACType
instance Sutori.Logger.Log.SutShow Sutori.TAC.TAC.SutSys


module Sutori.SymTable.Symbol

-- | Represents a basic symbol
class SutSymbol a
symID :: SutSymbol a => a -> SutID
symCat :: SutSymbol a => a -> SymbolCat
symScope :: SutSymbol a => a -> Scope

-- | Represents a symbol which also has some parameters
class SutSymbol a => ParametricSymbol a
symParams :: ParametricSymbol a => a -> [SutParam]

-- | Represents a symbol with a type
class SutSymbol a => TypedSymbol a
symType :: TypedSymbol a => a -> SutTypeID

-- | Represents a symbol that holds an AST
class SutSymbol a => ASTSymbol a
symAST :: ASTSymbol a => a -> SutAST
symPreAST :: ASTSymbol a => a -> SutAST

-- | A <a>Scope</a> is just a number uniquely representing a scope (NOT a
--   level, but an ID)
type Scope = Int

-- | A <a>SutParam</a> represents a function parameter, and it has a kind,
--   type and ID
data SutParam
SutParam :: Bool -> SutTypeID -> SutID -> SutParam

-- | Whether it is a reference or a value parameter
[isRef] :: SutParam -> Bool

-- | The type of the parameter
[paramType] :: SutParam -> SutTypeID

-- | The ID of the parameter
[paramID] :: SutParam -> SutID

-- | A (top-level) module
data SymModule
SymModule :: SutID -> SutAST -> SymModule

-- | A (top-level) function
data SymFunction
SymFunction :: SutID -> SutTypeID -> [SutParam] -> SutAST -> (Maybe SutAST) -> SymFunction

-- | A person who may do things in the story
data SymPerson
SymPerson :: SutID -> Scope -> SymPerson

-- | A variable
data SymVariable
SymVariable :: SutID -> Scope -> SutTypeID -> SymVariable

-- | A reference to a (now named) type
data SymType
SymType :: SutID -> Scope -> SutTypeID -> SymType

-- | Boxed SutSymbols for the table to handle
data SutSymbol'
SymModule' :: SymModule -> SutSymbol'
SymFunction' :: SymFunction -> SutSymbol'
SymPerson' :: SymPerson -> SutSymbol'
SymVariable' :: SymVariable -> SutSymbol'
SymType' :: SymType -> SutSymbol'
data SymbolCat
CatModule :: SymbolCat
CatPerson :: SymbolCat
CatType :: SymbolCat
CatVariable :: SymbolCat
CatFunction :: SymbolCat
CatMember :: SymbolCat
isModule :: SymbolCat -> Bool
isFunction :: SymbolCat -> Bool
isPerson :: SymbolCat -> Bool
isType :: SymbolCat -> Bool
isVariable :: SymbolCat -> Bool

-- | Helper to abstract the True/False isRef field
paramByValue :: SutTypeID -> SutID -> SutParam

-- | Helper to abstract the True/False isRef field
paramByRef :: SutTypeID -> SutID -> SutParam
unBoxFunction :: SutSymbol' -> SymFunction
unBoxPerson :: SutSymbol' -> SymPerson
unBoxVariable :: SutSymbol' -> SymVariable
unBoxModule :: SutSymbol' -> SymModule
unBoxType :: SutSymbol' -> SymType
instance GHC.Classes.Eq Sutori.SymTable.Symbol.SutParam
instance Sutori.SymTable.Symbol.SutSymbol Sutori.SymTable.Symbol.SutSymbol'
instance Sutori.SymTable.Symbol.SutSymbol Sutori.SymTable.Symbol.SymType
instance Sutori.SymTable.Symbol.TypedSymbol Sutori.SymTable.Symbol.SymType
instance Sutori.SymTable.Symbol.SutSymbol Sutori.SymTable.Symbol.SymVariable
instance Sutori.SymTable.Symbol.TypedSymbol Sutori.SymTable.Symbol.SymVariable
instance Sutori.SymTable.Symbol.SutSymbol Sutori.SymTable.Symbol.SymPerson
instance Sutori.SymTable.Symbol.SutSymbol Sutori.SymTable.Symbol.SymFunction
instance Sutori.SymTable.Symbol.TypedSymbol Sutori.SymTable.Symbol.SymFunction
instance Sutori.SymTable.Symbol.ParametricSymbol Sutori.SymTable.Symbol.SymFunction
instance Sutori.SymTable.Symbol.ASTSymbol Sutori.SymTable.Symbol.SymFunction
instance Sutori.SymTable.Symbol.SutSymbol Sutori.SymTable.Symbol.SymModule
instance Sutori.SymTable.Symbol.ASTSymbol Sutori.SymTable.Symbol.SymModule


module Sutori.SymTable.Table

-- | A <a>SymTable</a> represents the SymTable of a Sutori parsing, so it
--   matches a SutID (symbol name) to a list of symbols
type SymTable = Map SutID [SutSymbol']

-- | Inserts a symbol into its ID stack in the map
insertSymbol :: SutSymbol' -> SymTable -> SymTable

-- | Updates (read: replaces) the head of the symbol stack (for this
--   symbol's ID
updateSymbol :: SutSymbol' -> SymTable -> SymTable

-- | Lookup the list of symbols using the given ID
lookupSymbols :: SutID -> SymTable -> Maybe [SutSymbol']

-- | Lookup the list of variables with an ID
lookupSymbolsVariable :: SutID -> SymTable -> [SymVariable]

-- | Lookup the list of functions with an ID
lookupSymbolsFunction :: SutID -> SymTable -> [SymFunction]

-- | Lookup the list of modules with an ID
lookupSymbolsModule :: SutID -> SymTable -> [SymModule]

-- | Lookup the list of types with an ID
lookupSymbolsType :: SutID -> SymTable -> [SymType]

-- | Lookup the list of persons with an ID
lookupSymbolsPerson :: SutID -> SymTable -> [SymPerson]

-- | Lookup all defined functions in a given scope
lookupAllFunctions :: Scope -> SymTable -> [SymFunction]


module Sutori.SymTable.Logger
instance Sutori.Logger.Log.SutShow Sutori.SymTable.Symbol.SymModule
instance Sutori.Logger.Log.SutShow Sutori.SymTable.Symbol.SymFunction
instance Sutori.Logger.Log.SutShow Sutori.SymTable.Symbol.SymPerson
instance Sutori.Logger.Log.SutShow Sutori.SymTable.Symbol.SymVariable
instance Sutori.Logger.Log.SutShow Sutori.SymTable.Symbol.SymType
instance Sutori.Logger.Log.SutShow Sutori.SymTable.Symbol.SutParam
instance Sutori.Logger.Log.SutShow Sutori.SymTable.Symbol.SymbolCat


-- | This module defines all the interaction with the table, along with the
--   symbols themselves, their different categories and payloads.
module Sutori.SymTable

-- | Represents a basic symbol
class SutSymbol a
symID :: SutSymbol a => a -> SutID
symCat :: SutSymbol a => a -> SymbolCat
symScope :: SutSymbol a => a -> Scope

-- | Boxed SutSymbols for the table to handle
data SutSymbol'
SymModule' :: SymModule -> SutSymbol'
SymFunction' :: SymFunction -> SutSymbol'
SymPerson' :: SymPerson -> SutSymbol'
SymVariable' :: SymVariable -> SutSymbol'
SymType' :: SymType -> SutSymbol'

-- | Represents a symbol that holds an AST
class SutSymbol a => ASTSymbol a
symAST :: ASTSymbol a => a -> SutAST
symPreAST :: ASTSymbol a => a -> SutAST

-- | Represents a symbol which also has some parameters
class SutSymbol a => ParametricSymbol a
symParams :: ParametricSymbol a => a -> [SutParam]

-- | A <a>Scope</a> is just a number uniquely representing a scope (NOT a
--   level, but an ID)
type Scope = Int

-- | A <a>SutParam</a> represents a function parameter, and it has a kind,
--   type and ID
data SutParam
SutParam :: Bool -> SutTypeID -> SutID -> SutParam

-- | Whether it is a reference or a value parameter
[isRef] :: SutParam -> Bool

-- | The type of the parameter
[paramType] :: SutParam -> SutTypeID

-- | The ID of the parameter
[paramID] :: SutParam -> SutID

-- | A (top-level) function
data SymFunction
SymFunction :: SutID -> SutTypeID -> [SutParam] -> SutAST -> (Maybe SutAST) -> SymFunction

-- | A (top-level) module
data SymModule
SymModule :: SutID -> SutAST -> SymModule

-- | A person who may do things in the story
data SymPerson
SymPerson :: SutID -> Scope -> SymPerson

-- | A <a>SymTable</a> represents the SymTable of a Sutori parsing, so it
--   matches a SutID (symbol name) to a list of symbols
type SymTable = Map SutID [SutSymbol']

-- | A reference to a (now named) type
data SymType
SymType :: SutID -> Scope -> SutTypeID -> SymType

-- | A variable
data SymVariable
SymVariable :: SutID -> Scope -> SutTypeID -> SymVariable
data SymbolCat
CatModule :: SymbolCat
CatPerson :: SymbolCat
CatType :: SymbolCat
CatVariable :: SymbolCat
CatFunction :: SymbolCat
CatMember :: SymbolCat

-- | Represents a symbol with a type
class SutSymbol a => TypedSymbol a
symType :: TypedSymbol a => a -> SutTypeID

-- | Inserts a symbol into its ID stack in the map
insertSymbol :: SutSymbol' -> SymTable -> SymTable

-- | Lookup the list of symbols using the given ID
lookupSymbols :: SutID -> SymTable -> Maybe [SutSymbol']

-- | Lookup the list of variables with an ID
lookupSymbolsVariable :: SutID -> SymTable -> [SymVariable]

-- | Lookup the list of persons with an ID
lookupSymbolsPerson :: SutID -> SymTable -> [SymPerson]

-- | Lookup the list of modules with an ID
lookupSymbolsModule :: SutID -> SymTable -> [SymModule]

-- | Lookup the list of types with an ID
lookupSymbolsType :: SutID -> SymTable -> [SymType]

-- | Lookup the list of functions with an ID
lookupSymbolsFunction :: SutID -> SymTable -> [SymFunction]

-- | Updates (read: replaces) the head of the symbol stack (for this
--   symbol's ID
updateSymbol :: SutSymbol' -> SymTable -> SymTable

-- | Helper to abstract the True/False isRef field
paramByValue :: SutTypeID -> SutID -> SutParam

-- | Helper to abstract the True/False isRef field
paramByRef :: SutTypeID -> SutID -> SutParam

-- | Lookup all defined functions in a given scope
lookupAllFunctions :: Scope -> SymTable -> [SymFunction]


module Sutori.Parser.TypeCheck

-- | Takes a conversion function from primitive to primitive and
--   checks/converts the given expression
checkPrimitiveType :: (SutPrimitive -> SutPrimitive) -> SutExpression -> SutExpression

-- | Checks if expression is or can be converted to numeric
checkNumeric :: SutExpression -> SutExpression

-- | Checks if expression is checked for equality
checkEq :: SutExpression -> SutExpression

-- | Checks if expression is or can be converted to a sortable type
checkSortable :: SutExpression -> SutExpression

-- | Checks if expression is or can be converted to boolean
checkBoolean :: SutExpression -> SutExpression

-- | Checks if expression is or can be converted to an index type
checkIndex :: SutExpression -> SutExpression

-- | Checks if expression is or can be converted to integer (index type)
checkInt :: SutExpression -> SutExpression

-- | Checks if expression is or can be converted to float
checkFloat :: SutExpression -> SutExpression

-- | Checks if expression is or can be converted to string for printing
checkPrintable :: SutExpression -> SutExpression


module Sutori.Monad.State

-- | Monadic Lexer/Parser current state.
data SutState

-- | Current error code, if any
SutState :: SutPosn -> String -> Char -> Int -> [Word8] -> Int -> String -> Bool -> SymTable -> [Scope] -> Set Scope -> Scope -> SutModule -> TACTable -> Int -> Int -> TypeGraph -> SutTypeID -> Bool -> SutError -> SutState

-- | Position at current input location
[lexerPosn] :: SutState -> SutPosn

-- | Current input
[lexerInput] :: SutState -> String

-- | Character before the input
[lexerChar] :: SutState -> Char

-- | Current startcode
[lexerStateCode] :: SutState -> Int

-- | Current bytes read
[lexerBytes] :: SutState -> [Word8]

-- | Current comment nesting
[lexerDepth] :: SutState -> Int

-- | Currently built string
[lexerString] :: SutState -> String

-- | True if currently on an open strin
[lexerStringOn] :: SutState -> Bool

-- | The symtable
[parserTable] :: SutState -> SymTable

-- | The scopes stack
[parserStack] :: SutState -> [Scope]

-- | The set of open scopes
[parserScopes] :: SutState -> Set Scope

-- | The next scope ID to open
[parserNextScope] :: SutState -> Scope

-- | The main module (where compilation began)
[mainModule] :: SutState -> SutModule

-- | The table of generated TAC
[tacTable] :: SutState -> TACTable

-- | The next triplet index/The size of the current table
[tacNext] :: SutState -> Int

-- | The next label for TAC generation
[tacLabel] :: SutState -> Int

-- | The constructed type graph
[typesGraph] :: SutState -> TypeGraph

-- | The next type ID to be introduced
[typesNextID] :: SutState -> SutTypeID

-- | Set the output to verbose of not
[logVerbose] :: SutState -> Bool
[errorCode] :: SutState -> SutError

-- | Initial state of a Sutori parse<i>scan</i>run
initialSutoriState :: SutState

-- | Get the current open scope
parserCurrentScope :: SutState -> Scope


module Sutori.Monad.Monad

-- | The Sutori monad. Composes state, logging and exception handling
type SutMonad a = ReaderT Options (StateT SutState (WriterT SutLogger (Except (SutError, SutLog)))) a

-- | Run the monad with a given action
runSutMonad :: SutMonad a -> Options -> SutState -> Except (SutError, SutLog) ((a, SutState), SutLogger)


module Sutori.Monad.Actions

-- | Run a monadic action only if verbose if turned on
whenVerbose :: SutMonad () -> SutMonad ()

-- | Run the monad with a given action
runSutMonad :: SutMonad a -> Options -> SutState -> Except (SutError, SutLog) ((a, SutState), SutLogger)

-- | Inserts a new scope into the parse
insertScope :: SutMonad ()

-- | Removes last scope from the parse
removeScope :: SutMonad ()

-- | Get the current open scope
parserCurrentScope :: SutState -> Scope

-- | Set the current error code for the compilation
setErrorCode :: SutError -> SutMonad ()


module Sutori.Monad

-- | The Sutori monad. Composes state, logging and exception handling
type SutMonad a = ReaderT Options (StateT SutState (WriterT SutLogger (Except (SutError, SutLog)))) a

-- | Monadic Lexer/Parser current state.
data SutState

-- | Current error code, if any
SutState :: SutPosn -> String -> Char -> Int -> [Word8] -> Int -> String -> Bool -> SymTable -> [Scope] -> Set Scope -> Scope -> SutModule -> TACTable -> Int -> Int -> TypeGraph -> SutTypeID -> Bool -> SutError -> SutState

-- | Position at current input location
[lexerPosn] :: SutState -> SutPosn

-- | Current input
[lexerInput] :: SutState -> String

-- | Character before the input
[lexerChar] :: SutState -> Char

-- | Current startcode
[lexerStateCode] :: SutState -> Int

-- | Current bytes read
[lexerBytes] :: SutState -> [Word8]

-- | Current comment nesting
[lexerDepth] :: SutState -> Int

-- | Currently built string
[lexerString] :: SutState -> String

-- | True if currently on an open strin
[lexerStringOn] :: SutState -> Bool

-- | The symtable
[parserTable] :: SutState -> SymTable

-- | The scopes stack
[parserStack] :: SutState -> [Scope]

-- | The set of open scopes
[parserScopes] :: SutState -> Set Scope

-- | The next scope ID to open
[parserNextScope] :: SutState -> Scope

-- | The main module (where compilation began)
[mainModule] :: SutState -> SutModule

-- | The table of generated TAC
[tacTable] :: SutState -> TACTable

-- | The next triplet index/The size of the current table
[tacNext] :: SutState -> Int

-- | The next label for TAC generation
[tacLabel] :: SutState -> Int

-- | The constructed type graph
[typesGraph] :: SutState -> TypeGraph

-- | The next type ID to be introduced
[typesNextID] :: SutState -> SutTypeID

-- | Set the output to verbose of not
[logVerbose] :: SutState -> Bool
[errorCode] :: SutState -> SutError

-- | Run the monad with a given action
runSutMonad :: SutMonad a -> Options -> SutState -> Except (SutError, SutLog) ((a, SutState), SutLogger)

-- | Get the current open scope
parserCurrentScope :: SutState -> Scope

-- | Set the current error code for the compilation
setErrorCode :: SutError -> SutMonad ()

-- | Initial state of a Sutori parse<i>scan</i>run
initialSutoriState :: SutState

-- | Inserts a new scope into the parse
insertScope :: SutMonad ()

-- | Removes last scope from the parse
removeScope :: SutMonad ()

-- | Run a monadic action only if verbose if turned on
whenVerbose :: SutMonad () -> SutMonad ()


module Sutori.TAC.CodeGen

-- | Appends to the TAC table a new triplet, references it on the
--   instructions TAC table
--   
--   Returns the Address of the inserted TAC
addTAC :: TAC -> SutMonad TACAddress
newLabel :: SutMonad TAC
genCode :: SutMonad TACTable
genCodeAST :: Int -> Int -> SutAST -> SutMonad ()

-- | Generates code for instructions
genCodeInstr :: Int -> Int -> SutInstruction -> SutMonad ()

-- | Generates code for expressions
--   
--   Each production returns the address (as temporal register) of the
--   resulting expression
genCodeExpr :: SutExpression -> SutMonad TACAddress


module Sutori.TAC
data TACTable

-- | Table of triplets
TACTable :: [Int] -> [TAC] -> TACTable

-- | Table of pointers to triplets
[tacInstructions] :: TACTable -> [Int]
[tacTriplets] :: TACTable -> [TAC]

-- | TACAddress for TAC Instructions
data TACAddress

-- | An actual ID from the source code. Identified using <a>SutID</a> and
--   <tt>Scope</tt>. Used for variables
TACName :: (SutID, Int) -> TACAddress

-- | A literal either explicit in the source code or calculated on the run.
TACLit :: SutLiteral -> TACAddress

-- | The TAC number that calculated the relevant expression.
TACID :: Int -> TACAddress

-- | An inc label to some code.
TACLabel :: Int -> TACAddress

-- | A TAC Instruction to be appended to the generated intermediate code
data TACType

-- | For simple expressions.
Basic :: SutOperator -> TACType
[tacOp] :: TACType -> SutOperator

-- | Copy operation, from a address to another
Copy :: TACType

-- | Address for an indirection
Addr :: TACType

-- | Unconditional jump, just where to.
Jump :: TACType

-- | Condition jump
JumpUnless :: TACType

-- | Assign a address from a indirect pointer.
Pointed :: TACType

-- | Stack a function parameter
Param :: TACType

-- | Call a function of so many (already stacked) parameters
Call :: TACType

-- | Return from a function (possibly a value).
Return :: TACType

-- | Perform a syscall (IO, Mem, else)
SysCall :: SutSys -> TACType
[tacSys] :: TACType -> SutSys

-- | TAC Instruction
data TAC

-- | Second address. Usually second operand. |A numbered label to output
--   literally
TAC :: TACType -> Maybe TACAddress -> Maybe TACAddress -> TAC

-- | Operation to perform
[tacType] :: TAC -> TACType

-- | First address. Usually first operand.
[tac1] :: TAC -> Maybe TACAddress
[tac2] :: TAC -> Maybe TACAddress
Label :: Int -> TAC

-- | A string label to output literally
FunLabel :: SutID -> TAC

-- | Appends to the TAC table a new triplet, references it on the
--   instructions TAC table
--   
--   Returns the Address of the inserted TAC
addTAC :: TAC -> SutMonad TACAddress
genCode :: SutMonad TACTable


module Sutori.Lexer.Internals

-- | Encode a Haskell String to a list of Word8 values, in UTF8 format.
--   Taken from Alex wrapper templates
utf8Encode :: Char -> [Word8]

-- | The type of the scanner's food (Current position, Previous character,
--   pending bytes on current character, current input)
type SutoriInput = (SutPosn, Char, [Word8], String)

-- | Alias needed by Alex
type AlexInput = SutoriInput

-- | Needed by alex for look-back. We don't use look-back now
alexInputPrevChar :: SutoriInput -> Char

-- | Needed by alex to read
alexGetByte :: SutoriInput -> Maybe (Word8, SutoriInput)

-- | Ignore the current character's pending bytes
ignorePendingBytes :: SutoriInput -> SutoriInput

-- | Hard-coded tab size for positioning
sutTabSize :: Int

-- | Move the scanner position given a character
lexerMove :: SutPosn -> Char -> SutPosn

-- | Read input
lexerGetInput :: SutMonad SutoriInput

-- | Set remaining input
lexerSetInput :: SutoriInput -> SutMonad ()


module Sutori.Error.Report

-- | The `<tt>error'</tt> log
logError :: SutLogger -> [(SutError, SutLog)]

-- | Logs a lexical error and continues
lexerError :: String -> SutMonad ()

-- | Logs a parsing error and throws out
parserError :: SutToken -> SutMonad a

-- | Logs a type error and continues
typeError :: SutExpression -> SutType -> SutType -> String -> SutMonad ()

-- | Logs an undefined symbol error and continues
undefinedError :: SutID -> SymbolCat -> String -> SutMonad ()

-- | Logs a duplicate symbol error and continues
duplicateSymbolError :: SutSymbol a => a -> SutMonad ()

-- | Logs a duplicate member error and continues
duplicateMemberError :: SutID -> SutMonad ()

-- | Logs a wrong number of parameters error and continues
argumentsNumberError :: SutID -> Int -> Int -> SutMonad ()


module Sutori.Error

-- | Different possible Sutori Errors
data SutError

-- | An unknown or malformed token was read
LexicalError :: SutError

-- | The source code does not follow Sutori grammar
GrammaticalError :: SutError

-- | A Type error occurred
TypeError :: SutError

-- | A symbol was used before it was defined
UndefinedSymbolError :: SutError

-- | A function was called with the wrong number of arguments
ArgumentsNumberError :: SutError

-- | A symbol was defined twice in the same scope
DuplicateSymbolError :: SutError

-- | The compiler failed for a known reason (not the user's fault)
InternalError :: SutError

-- | The lack of error
NoError :: SutError

-- | The `<tt>error'</tt> log
logError :: SutLogger -> [(SutError, SutLog)]

-- | Logs a lexical error and continues
lexerError :: String -> SutMonad ()

-- | Logs a parsing error and throws out
parserError :: SutToken -> SutMonad a

-- | Logs a type error and continues
typeError :: SutExpression -> SutType -> SutType -> String -> SutMonad ()

-- | Logs an undefined symbol error and continues
undefinedError :: SutID -> SymbolCat -> String -> SutMonad ()

-- | Logs a duplicate symbol error and continues
duplicateSymbolError :: SutSymbol a => a -> SutMonad ()

-- | Logs a duplicate member error and continues
duplicateMemberError :: SutID -> SutMonad ()

-- | Logs a wrong number of parameters error and continues
argumentsNumberError :: SutID -> Int -> Int -> SutMonad ()


module Sutori.Parser.Symbols

-- | Finds an existent <a>SutType</a> from its <a>SutTypeID</a>
findExistentType :: SutTypeID -> SutMonad SutType

-- | Finds the existent typeID or inserts the type and gets the new ID
findTypeID :: SutType -> SutMonad SutTypeID

-- | Finds the <a>SutTypeID</a> from a <a>SutID</a>
findType :: SutID -> SutMonad SutTypeID

-- | Checks if the given Person already exists
findPerson :: SutID -> SutMonad SutID

-- | Checks if the given function already exists, returns the <a>SutID</a>
findFunctionID :: SutID -> SutMonad SutID

-- | Checks if the given function already exists, returns the
--   <a>SutSymbol</a>, if any
findFunction :: SutID -> SutMonad (Maybe SymFunction)

-- | Checks if the given variable already exists, returns the <a>SutID</a>
--   wrapped as a <a>SutExpression</a>
findVariable :: SutID -> SutMonad SutExpression

-- | Checks the living scopes for the symbols with given <a>SutID</a>
lookupInScope :: SutSymbol a => (SutID -> SymTable -> [a]) -> SutID -> SutMonad [a]

-- | Crosses the living scopes with the given <a>SutSymbol</a>s
--   
--   Uses the fact the both lists are ordered in decreasing order of
--   <a>SutID</a>
inScope :: SutSymbol a => [a] -> SutMonad [a]


module Sutori.Parser.Expressions

-- | Represents a transformation from an expression to another
--   
--   Ex. Change of type to TypeError
type ExprTransform = SutExpression -> SutExpression

-- | Represents a unary operation expression constructor
type SutUnaryOp = SutExpression -> SutMonad SutExpression

-- | Represents a binary operation expression constructor
type SutBinaryOp = SutExpression -> SutExpression -> SutMonad SutExpression
literalBool :: Bool -> SutMonad SutExpression
literalChar :: String -> SutMonad SutExpression
literalInt :: Int -> SutMonad SutExpression
literalFloat :: Float -> SutMonad SutExpression
literalString :: String -> SutMonad SutExpression

-- | Constructs an array from the list of expressions All expressions must
--   be of the same type
--   
--   Note: Sutori grammar doesn't allow empty arrays
constructArray :: [SutExpression] -> SutMonad SutExpression

-- | Constructs a struct from the list of ID -&gt; Expression mappings
--   
--   Right now, we implement these by storing the member IDs into the type
--   graph
--   
--   Note: We do not allow duplicated member IDs
constructStruct :: [(SutID, SutExpression)] -> SutMonad SutExpression
unaryPlus :: SutUnaryOp
unaryMinus :: SutUnaryOp
unaryNot :: SutUnaryOp
opAddition :: SutBinaryOp
opSubstraction :: SutBinaryOp
opMultiplication :: SutBinaryOp
opDivision :: SutBinaryOp
opIntDivision :: SutBinaryOp
opModulo :: SutBinaryOp
opPower :: SutBinaryOp

-- | (&gt;=) receives two "sortable" types
opGreaterEqual :: SutBinaryOp

-- | (&lt;=) receives two "sortable" types
opLessEqual :: SutBinaryOp

-- | (&lt;) receives two "sortable" types
opLess :: SutBinaryOp

-- | (&gt;) receives two "sortable" types
opGreater :: SutBinaryOp

-- | Equality check receives two "equalable" types
opEqual :: SutBinaryOp

-- | NotEquality check receives two "equalable" types
opNotEqual :: SutBinaryOp

-- | Boolean AND receives two booleans
opAnd :: SutBinaryOp

-- | Boolean OR receives two booleans
opOr :: SutBinaryOp

-- | An assignement to the left side of the value from the right side
--   
--   This checks that a general type for converting the right side exists
--   
--   Note: An assignment is both an instruction and an expression
--   
--   Note: It is known the left side is assignable
--   
--   Note: Right side must be of a more specific type than left side
assignment :: SutBinaryOp

-- | The indexation of the array in the left side with the key/index on the
--   right side
--   
--   This checks the left side is actually of an array type
--   
--   Note: It is known the left side is assignable and the right side is
--   int expression
--   
--   Note: Left side must be array type
arrayGet :: SutBinaryOp

-- | The access to a member<i>component (ID right) of a thing</i>machine
--   (left)
--   
--   This checks left side is either a Machine or a Thing, and that it
--   knows a member with the ID
--   
--   Note: It is known the left lise is assignable
memberGet :: SutExpression -> SutID -> SutMonad SutExpression

-- | A call to a function (ID) with parameters (given list)
--   
--   This checks for the correct number of arguments and their types
--   
--   Note: Left side is known to be existent function (?)
functionCall :: SutID -> [SutExpression] -> SutMonad SutExpression

-- | Creates a dereferencing expression for the given expression
--   
--   This checks the expression is a direction to somewhere
--   
--   Note: It is know the expression is assignable
dereference :: SutUnaryOp

-- | Creates a direction to a value of type given
--   
--   Note: We are already given the existent type ID
--   
--   Note: Left side is known to be a person
createPointer :: SutID -> SutTypeID -> SutMonad SutExpression


module Sutori.Parser.Definitions

-- | Decides on whether the given <a>SutID</a> was used for a different
--   symbol in the same scope
whenSymbolIsNew :: SutSymbol a => (SutID -> SymTable -> [a]) -> SutID -> SutMonad () -> SutMonad ()

-- | Defines a new variable of given type and optionally assigns it an
--   initial value.
defVariable :: SutID -> SutTypeID -> (SutID, Maybe SutExpression) -> SutMonad (Maybe SutInstruction)

-- | Associates the SutID to the newly constructed type, assuming the name
--   has not been used before
defType :: SutID -> SutID -> SutTypeID -> SutMonad ()

-- | Includes a new person into the story
defPerson :: SutID -> SutMonad ()

-- | Defines a new parameter into a function's scope.
defParams :: [SutParam] -> SutMonad [SutInstruction]

-- | Defined a list of variables and returns a list of instructions, if any
--   definition included an assigment
defVariables :: SutID -> SutTypeID -> [(SutID, Maybe SutExpression)] -> SutMonad [SutInstruction]

-- | Defines a module for importing/exporting
--   
--   Right now it's basically a stub as there's only one module and the
--   data structure only keeps the <a>SutID</a> and <a>AST</a>
defModule :: SutID -> SutAST -> SutMonad ()

-- | Defines a AST-able function (updates the top function with this ID's
--   AST)
--   
--   Note: We are now in the scope the function is being defined
defineFunction :: SutID -> SutAST -> SutMonad ()

-- | Inserts a new function symbol with a given name, type and parameters,
--   if none is present (no body yet)
--   
--   Is this action's job to build the initial function symbol (and that
--   includes the PreAST)
--   
--   Note: We are inside the function's scope, so we need to insert the
--   symbol in the second-to-last scope
insertFunction :: SutID -> SutTypeID -> [SutParam] -> SutMonad SutID


module Sutori.Lexer.Lexer

-- | Scans for next token, but passes it though checks first
lexerScanClean :: SutMonad SutToken

-- | Run the lexer on a given input string, with a given monadic action
runLexer :: Options -> String -> SutMonad a -> Either (SutError, SutLog) (((a, SutState), SutLogger))

-- | Run the lexer with no options (default options)
runLexer' :: () => String -> SutMonad a -> Either (SutError, SutLog) ((a, SutState), SutLogger)

-- | Run the lexer on a given string, get the resulting tokens
runLexerScan :: Options -> String -> Either (SutError, SutLog) ((([SutToken], SutState), SutLogger))

-- | Run the lexer, but receive a continuation (Used by Happy)
lexwrap :: (SutToken -> SutMonad a) -> SutMonad a

-- | Gets all tokens recursively
lexerLoop :: SutMonad [SutToken]


module Sutori.Lexer

-- | Scans for next token, but passes it though checks first
lexerScanClean :: SutMonad SutToken

-- | Run the lexer on a given input string, with a given monadic action
runLexer :: Options -> String -> SutMonad a -> Either (SutError, SutLog) (((a, SutState), SutLogger))

-- | Run the lexer with no options (default options)
runLexer' :: () => String -> SutMonad a -> Either (SutError, SutLog) ((a, SutState), SutLogger)

-- | Run the lexer on a given string, get the resulting tokens
runLexerScan :: Options -> String -> Either (SutError, SutLog) ((([SutToken], SutState), SutLogger))

-- | Run the lexer, but receive a continuation (Used by Happy)
lexwrap :: (SutToken -> SutMonad a) -> SutMonad a

-- | Sutori token classes. Their RegEx' are defined in Alex file
data SutToken
SutTkEOF :: SutToken
BLOCK_OPEN :: SutToken
BLOCK_CLOSE :: SutToken
PROGRAM_INI :: SutToken
PROGRAM_FIN :: SutToken
FUNCTION_INI :: SutToken
FUNCTION_DECLARE :: SutToken
FUNCTION_DEFINE :: SutToken
S_andthatswhere :: SutToken
S_therewas :: SutToken
S_brokea :: SutToken
S_broughta :: SutToken
S_comesfrom :: SutToken
S_dreamsof :: SutToken
S_keepsdreamingof :: SutToken
S_madea :: SutToken
S_madeof :: SutToken
S_therewasa :: SutToken
S_toldthatstory :: SutToken
S_invented :: SutToken
S_itsa :: SutToken
S_andnothingelse :: SutToken
S_wewillskipthis :: SutToken
TYPE_INT :: SutToken
TYPE_FLOAT :: SutToken
TYPE_CHAR :: SutToken
TYPE_VOID :: SutToken
TYPE_BOOL :: SutToken
TYPE_ARRAY :: SutToken
TYPE_STRUCT :: SutToken
TYPE_UNION :: SutToken
TYPE_STRING :: SutToken
TYPE_POINTER :: SutToken
OPEN_PAREN :: SutToken
OPEN_BRACKETS :: SutToken
OPEN_BRACES :: SutToken
CLOSE_PAREN :: SutToken
CLOSE_BRACKETS :: SutToken
CLOSE_BRACES :: SutToken
ELLIPSIS :: SutToken
PERIOD :: SutToken
COMMA :: SutToken
COLON :: SutToken
SEMICOLON :: SutToken
QUESTIONMARK :: SutToken
EXCLAMATION :: SutToken
ARROW_RIGHT :: SutToken
PLUS :: SutToken
MINUS :: SutToken
EQUAL :: SutToken
ASSIGNMENT :: SutToken
ASTERISK :: SutToken
PERCENT :: SutToken
SLASH :: SutToken
DIV :: SutToken
NOT_EQUAL :: SutToken
GREATER_EQUAL :: SutToken
LESS_EQUAL :: SutToken
GREATER :: SutToken
LESS :: SutToken
POWER :: SutToken
AND :: SutToken
OR :: SutToken
WITH :: SutToken
YOUR :: SutToken
OF :: SutToken
EITHER :: SutToken
TO :: SutToken
WHEN :: SutToken
OTHERWISE :: SutToken
TIMES :: SutToken
SutTkBool :: Bool -> SutToken
[tokenBool] :: SutToken -> Bool
SutTkChar :: String -> SutToken
[tokenChar] :: SutToken -> String
SutTkFloat :: Float -> SutToken
[tokenFloat] :: SutToken -> Float
SutTkInt :: Int -> SutToken
[tokenInt] :: SutToken -> Int
SutTkString :: String -> SutToken
[tokenString] :: SutToken -> String
SutTkError :: String -> SutToken
[tokenError] :: SutToken -> String
SutTkID :: String -> SutToken
[tokenID] :: SutToken -> String

-- | Initial position of the scanner
initialPosn :: SutPosn

-- | Source position (Characters before, Row number, Column number)
data SutPosn

-- | Gets all tokens recursively
lexerLoop :: SutMonad [SutToken]


module Sutori.Parser.Parser

-- | Parses an entire Sutori file (module)
parseModule :: SutMonad ()

-- | Parses a Sutori expression
parseExpression :: SutMonad SutExpression

-- | Parses a Sutori type expression
parseType :: SutMonad SutTypeID


module Sutori.Parser

-- | Parses an entire Sutori file (module)
parseModule :: SutMonad ()

-- | Parses a Sutori expression
parseExpression :: SutMonad SutExpression

-- | Parses a Sutori type expression
parseType :: SutMonad SutTypeID


module Sutori.CLI.Router

-- | Routes a call to the CLI with passed options and files into the
--   correct mode of operation
route :: (Options, [FilePath]) -> IO ()


module Sutori.CLI

-- | Routes a call to the CLI with passed options and files into the
--   correct mode of operation
route :: (Options, [FilePath]) -> IO ()
